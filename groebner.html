<HTML>
<HEAD>
<TITLE>4ti2 -- Computation of Hilbert bases, Graver bases, toric Groebner bases, and more</TITLE>
</HEAD>

<BODY bgcolor = white>

<center>
<table border=0 width=90% cellspacing=5 cellpadding=5>
<tr>
  <th>
    <font size=6>groebner</font>
  </th>
</tr>
</table>
</center>

This code computes a generating set and then a Gr&ouml;bner basis

<ul>
<li> of the toric ideal of a matrix A or
<li> of the lattice ideal of a lattice L
</ul>

with respect to the term ordering specified in 'fileName.cost'. If 
'fileName.cost' is not present, a default term ordering is used. Note
that you may specify any term ording with this new version by simply
putting a matrix into 'fileName.cost' that encodes this term
ordering. There are no short cuts like '--lexicographic' coded into
'groebner' at the moment. <p>

See

<ul>
<li> A.M. Bigatti and R. LaScala and L. Robbiano. Computing toric
     ideals. Journal of Symbolic Computation 27 (1999), 351--365.
<li> R. Gebauer and H. M. M&ouml;ller. On an installation of
     Buchberger's algorithm. Journal of Symbolic Computation 6 (1988),
     275--286. 
<li> R. Hemmecke and P. Malkin. Computing generating sets of lattice
ideals. e-print arXiv:math.CO/0508359, 2005. 
<li> S. Hosten and B. Sturmfels. GRIN: An implementation of
     Gr&ouml;bner bases for integer program- ming. In: "Integer
     programming and combinatorial optimisation", E. Balas and
     J. Clausen, eds., LNCS 920, Springer-Verlag, 1995, 267--276.
</ul>

for more details on the algorithms implemented.<p>


<b>Usage</b>

<pre>
./groebner [--options] fileName
</pre>
<p>

<b>Examples</b>

<pre>
./groebner fileName
./groebner --quiet fileName
</pre>
<p>

<b>Default behavior</b>

<ul>
<li> If 'fileName.cost' is not present, a default term ordering is used.
<li> If existent, the Gr&ouml;bner basis is computed from an ideal
generating set given in 'fileName.mar' or in 'fileName.gro'. 
</ul>
<p>

<b>Comments</b>

<ul>
<li> There are two major algorithms implemented to find a generating set
     for the lattice ideal:
     <ul>
     <li> Saturation algorithm
     <li> Project-amd-Lift algorithm (default)
     </ul>
<li> Both use a completion procedure whose critical-pair selection
     strategy can be driven by:
     <ul>
     <li> the simplest and straight-forward FIFO strategy (default)
     <li> a selection by increasing weights, where a weights matrix
	  should be specified in 'fileName.weights'.
     <li> the Gebauer-and-M&ouml;ller criteria to eliminate many critical
	  pairs. It seems to be most effective, when 4ti2 is not
	  having a generating set available, as it is the case in the
	  Saturation algorithm. Therefore, this option is set as
	  default if the Saturation algorithm is chosen. <br>
	  Moreover, this strategy is a useful alternative to the
	  'normal' strategy if this one is performing badly.  
     </ul>
<li> Auto-reduction is turned on by default to avoid unnecessarily
     huge intermediate sets. You may turn it off completely by setting
     the option 'auto-reduce-freq=-1'.
<li> The default settings worked pretty well in our experiments. But, if
     you have 3 processors to spare, it is probably best to start 3
     computations in parallel each with different algorithms.
</ul>
<p>

<table border=1 width=90% cellspacing=5 cellpadding=5>
<tr>
<th align=left>
Option<br>

</th>
<th align=left>
Short-hand<br>

</th>
<th align=left>
Effect
</th>
</tr>

<tr>
<th align=left>
--quiet
</th>
<th align=left>
-q
</th>
<th align=left>
no output is written to the screen
</th>
</tr>

<tr>
<th align=left>
--force
</th>
<th align=left>
-f
</th>
<th align=left>
forces full computation from scratch regardless of existing files like
'fileName.gro' 
</th>
</tr>

<tr>
<th align=left>
--saturation
</th>
<th align=left>
-s
</th>
<th align=left>
Use the Saturation algorithm of Hosten & Sturmfels.
</th>
</tr>

<tr>
<th align=left>
--project-and-lift
</th>
<th align=left>
-p
</th>
<th align=left>
Use the Project-and-Lift algorithm. (default)
</th>
</tr>

<tr>
<th align=left>
--normal
</th>
<th align=left>
-n
</th>
<th align=left>
Use the straight-forward completion procedure. (default)<br>
Critical pairs are queued and chosen by FIFO.
</th>
</tr>

<tr>
<th align=left>
--weighted
</th>
<th align=left>
-w
</th>
<th align=left>
Use the weighted completion procedure.<br>
Critical pairs are chosen by increasing weight.
</th>
</tr>

<tr>
<th align=left>
--gebauer-moeller
</th>
<th align=left>
-g
</th>
<th align=left>
Use the Gebauer and Moeller criteria.
</th>
</tr>

<tr>
<th align=left>
--auto-reduce-freq=n
</th>
<th align=left>
-an
</th>
<th align=left>
Set the frequency of auto reduction to 'n' iterations. (n=20,000
default)<br>
Set 'auto-reduce-freq=-1' to switch off auto-reduction.
</th>
</tr>
</table>
<p>

<table border=1 width=90% cellspacing=5 cellpadding=5>
<tr>
<th align=left>
Output file
</th>
<th align=left>
Content
</th>
</tr>

<tr>
<th align=left>
fileName.gro
</th>
<th align=left>
list of Gr&ouml;bner basis elements
</th>
</tr>
</table>



</BODY>
